// Copyright 2020 The searKing Author. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by "go-sqlx -type SqlData --linecomment"; DO NOT EDIT.

package common

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"

	reflect_ "github.com/searKing/golang/go/reflect"
	"github.com/searKing/golang/go/strings"
)

// SqlData represents an orm of table sql_data.
// SqlData implements the Scanner interface so
// it can be used as a scan destination, similar to sql.NullString.

// TableName returns table's name
func (_ SqlData) TableName() string {
	return "sql_data"
}

// MarshalMap marshal themselves into or append a valid map
func (m SqlData) MarshalMap(valueByCol map[string]interface{}) map[string]interface{} {
	if valueByCol == nil {
		valueByCol = map[string]interface{}{}
	}
	valueByCol[m.MapColumn(SqlDataFieldId)] = m.Id
	valueByCol[m.MapColumn(SqlDataFieldCreatedAt)] = m.CreatedAt
	valueByCol[m.MapColumn(SqlDataFieldUpdatedAt)] = m.UpdatedAt
	valueByCol[m.MapColumn(SqlDataFieldIsDeleted)] = m.IsDeleted
	valueByCol[m.MapColumn(SqlDataFieldDeletedAt)] = m.DeletedAt
	valueByCol[m.MapColumn(SqlDataFieldVersion)] = m.Version
	return valueByCol
}

// UnmarshalMap is the interface implemented by types
// that can unmarshal a map description of themselves.
func (m *SqlData) UnmarshalMap(valueByCol map[string]interface{}) error {
	for col, val := range valueByCol {
		switch col {
		case m.MapColumn(SqlDataFieldId):
			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.Id)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumn(SqlDataFieldCreatedAt):
			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.CreatedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumn(SqlDataFieldUpdatedAt):
			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.UpdatedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumn(SqlDataFieldIsDeleted):
			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.IsDeleted)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumn(SqlDataFieldDeletedAt):
			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.DeletedAt)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		case m.MapColumn(SqlDataFieldVersion):
			data, err := json.Marshal(val)
			if err != nil {
				return fmt.Errorf("marshal col %q, got %w", col, err)
			}
			err = json.Unmarshal(data, &m.Version)
			if err != nil {
				return fmt.Errorf("unmarshal col %q, got %w", col, err)
			}
		}
	}
	return nil
}

// 列名
type SqlDataField int

const (
	SqlDataFieldId        SqlDataField = iota
	SqlDataFieldCreatedAt SqlDataField = iota
	SqlDataFieldUpdatedAt SqlDataField = iota
	SqlDataFieldIsDeleted SqlDataField = iota
	SqlDataFieldDeletedAt SqlDataField = iota
	SqlDataFieldVersion   SqlDataField = iota
)

func (f SqlDataField) String() string {
	switch f {
	case SqlDataFieldId:
		return "id"
	case SqlDataFieldCreatedAt:
		return "created_at"
	case SqlDataFieldUpdatedAt:
		return "updated_at"
	case SqlDataFieldIsDeleted:
		return "is_deleted"
	case SqlDataFieldDeletedAt:
		return "deleted_at"
	case SqlDataFieldVersion:
		return "version"
	}
	return "SqlDataField(" + strconv.FormatInt(int64(f), 10) + ")"
}

func (a SqlData) ColumnEditor() *SqlDataColumns {
	return &SqlDataColumns{
		arg: a,
	}
}
func (a SqlData) Column(col SqlDataField) string {
	return strings.SnakeCase(col.String())
}

func (a SqlData) TableColumn(col SqlDataField) string {
	return fmt.Sprintf("%s.%s", a.TableName(), a.Column(col))
}

func (a SqlData) MapColumn(col SqlDataField) string {
	return fmt.Sprintf("%s_%s", a.TableName(), a.Column(col))
}

// columns

type SqlDataColumns struct {
	arg  SqlData
	cols []string
}

func (c SqlDataColumns) Columns(cols ...string) []string {
	return append(c.cols, cols...)
}

func (c *SqlDataColumns) AppendColumn(col SqlDataField, forceAppend bool) *SqlDataColumns {
	var zero = reflect_.IsZeroValue(reflect.ValueOf(c.arg).FieldByName(col.String()))

	if forceAppend || !zero {
		c.cols = append(c.cols, strings.SnakeCase(col.String()))
	}
	return c
}

func (c *SqlDataColumns) AppendAll() *SqlDataColumns {
	return c.
		AppendColumn(SqlDataFieldId, false).
		AppendColumn(SqlDataFieldCreatedAt, false).
		AppendColumn(SqlDataFieldUpdatedAt, false).
		AppendColumn(SqlDataFieldIsDeleted, false).
		AppendColumn(SqlDataFieldDeletedAt, false).
		AppendColumn(SqlDataFieldVersion, false).
		self()
}

func (c *SqlDataColumns) self() *SqlDataColumns {
	return c
}
